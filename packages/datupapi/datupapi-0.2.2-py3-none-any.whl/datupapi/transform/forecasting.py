import boto3
import numpy as np
import os
import pandas as pd

from datupapi.configure.config import Config
from datupapi.extract.io import IO

class Forecasting(Config):

    def __init__(self, config_file, logfile, log_path, *args, **kwargs):
        Config.__init__(self, config_file=config_file, logfile=logfile)
        self.log_path = log_path


    def concat_forecasts_export(self, datalake_path_=None, intervals_fill=None):
        """
        Return a dataframe including all forecasts partitions generated by create_forecast_export API's calling

        :param datalake_path: Datalake path to the backtests' partitions files
        :param intervals_fill: List of intevals to fill with -9999, since no usage (e.g. ['Lo95', 'Up95'])
        :return df_forecasts: Dataframe concatenating all backtests estimates

        >>> df = concat_forecasts_export(datalake_path_='/path/to/backtests', intervals_fill=['Lo95', 'Up95'])
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        df_forecasts = pd.DataFrame()
        try:
            for part in range(0, 30):
                df_tmp = io.download_object(datalake_path=datalake_path_ + str(part) + '.csv')
                df_forecasts = pd.concat([df_forecasts, df_tmp], axis='rows')
            df_forecasts['date'] = pd.to_datetime(df_forecasts['date'], format='%Y-%m-%d')
            df_forecasts = df_forecasts.rename(columns={'item_id': 'Item',
                                                        'date': 'Date',
                                                        'p5': 'Forecast Lo95',
                                                        'p20': 'Forecast Lo80',
                                                        'p40': 'Forecast Lo60',
                                                        'p50': 'Forecast Point',
                                                        'p60': 'Forecast Up60',
                                                        'p70': 'Forecast Up80',
                                                        'p95': 'Forecast Up95'
                                                        }
                                               )
            for interval in intervals_fill:
                df_forecasts['Forecast ' + interval] = -9999
            forecast_cols = [col for col in df_forecasts.columns if all(subcol not in col for subcol in ['Item', 'Date'])]
            df_forecasts[forecast_cols] = df_forecasts[forecast_cols].applymap(lambda x: 0 if x < 0 else x)\
                                                                     .applymap(lambda x: round(x))
            df_forecasts['Target'] = 0
            df_forecasts['Week'] = df_forecasts['Date'].dt.isocalendar()['week']
            df_forecasts = df_forecasts[['Date', 'Week', 'Item', 'Target', 'Forecast Point',
                                         'Forecast Lo95', 'Forecast Lo80', 'Forecast Lo60',
                                         'Forecast Up60', 'Forecast Up80', 'Forecast Up95']]
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecasts


