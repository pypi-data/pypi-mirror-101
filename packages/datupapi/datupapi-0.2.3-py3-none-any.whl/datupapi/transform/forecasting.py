import boto3
import numpy as np
import os
import pandas as pd

from datupapi.configure.config import Config
from datupapi.extract.io import IO

class Forecasting(Config):

    io = IO(config_file='config.yml', logfile='data_extraction', log_path='output/logs')

    def __init__(self, config_file, logfile, log_path, *args, **kwargs):
        Config.__init__(self, config_file=config_file, logfile=logfile)
        self.log_path = log_path


    def format_forecasts_export(self, df_forecasts, intervals_fill=None):
        """
        Return a dataframe including all forecasts partitions generated by create_forecast_export API's calling

        :param df_forecasts: Dataframe with all contatenated forecasts
        :param intervals_fill: List of intevals to fill with -9999, since no usage (e.g. ['Lo95', 'Up95'])
        :return df_forecasts: Dataframe concatenating all backtests estimates

        >>> df = format_forecasts_export(df_forecast, intervals_fill=['Lo95', 'Up95'])
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        try:
            df_forecasts['date'] = pd.to_datetime(df_forecasts['date'], format='%Y-%m-%d')
            df_forecasts = df_forecasts.rename(columns={'item_id': 'Item',
                                                        'date': 'Date',
                                                        'p5': 'Forecast Lo95',
                                                        'p20': 'Forecast Lo80',
                                                        'p40': 'Forecast Lo60',
                                                        'p50': 'Forecast Point',
                                                        'p60': 'Forecast Up60',
                                                        'p80': 'Forecast Up80',
                                                        'p95': 'Forecast Up95'
                                                        }
                                               )
            for interval in intervals_fill:
                df_forecasts['Forecast ' + interval] = -9999
            forecast_cols = [col for col in df_forecasts.columns if all(subcol not in col for subcol in ['Item', 'Date'])]
            df_forecasts[forecast_cols] = df_forecasts[forecast_cols].applymap(lambda x: 0 if x < 0 else x)\
                                                                     .applymap(lambda x: round(x))
            df_forecasts['Target'] = 0
            df_forecasts['Week'] = df_forecasts['Date'].dt.isocalendar()['week']
            df_forecasts = df_forecasts[['Date', 'Week', 'Item', 'Target', 'Forecast Point',
                                         'Forecast Lo95', 'Forecast Lo80', 'Forecast Lo60',
                                         'Forecast Up60', 'Forecast Up80', 'Forecast Up95']]
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecasts


    def compute_errors_from_backtests(self, df_forecast, df_backtest, error_types=['WMAPE', 'MASE']):
        """
        Return a dataframe attaching the specified errors from the averaged out values in backtests

        :param df_forecast: Original dataframe including all items' forecasts
        :param df_backtest: Dataframe including all items' backtests
        :param error_types: List of error to attach to the forecast dataframe. Default WMAPE and MASE
        :return df_forecast: Output forecast dataframe including specified errors

        >>> df = compute_errors_from_backtests(df_forecast, df_backtest, error_types=['WMAPE', 'MASE'])
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        error_dict = {error_type: 'mean' for error_type in error_types}
        try:
            df_errors = df_backtest.groupby('Item', as_index=True)\
                                   .agg(error_dict)\
                                   .applymap(lambda x: round(x, 2))\
                                   .reset_index(drop=False)
            df_forecast = pd.merge(df_forecast, df_errors, on='Item', how='left')
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecast


    def compute_interval_per_backtests(self, df_forecast, backtest_names=None, datalake_path_=None):
        """
        Return a dataframe attaching the forecast interval for each backtest dataset

        :param df_forecast: Original dataframe including all items' forecasts
        :param backtest_names: List of backtests names to concat, e.g. alpha, beta, gamma, delta and eps
        :param datalake_path_: Datalake path to download the backtest files from. Do not include bucket name
        :return df_forecast: Output forecast dataframe including specified interval per backtest

        >>> df = compute_interval_per_backtests(df_forecast, backtest_names=['alpha', 'beta'], datalake_path_='path/tp/backtests/folder')
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        interval_dict = {}
        try:
            for back_ix, backtest in enumerate(backtest_names):
                df_back = self.io.download_csv(q_name='Qback-' + backtest, datalake_path=datalake_path_)
                for item in df_back['Item']:
                    interval_dict.update({item: interval for interval in df_back.loc[df_back['Item'] == item, 'Suggested Interval']})
                    df_forecast.loc[df_forecast['Item'] == item, 'Sugg Interval Backtest ' + str(back_ix + 1)] = df_forecast.loc[df_forecast['Item'] == item, 'Item']\
                               .map(interval_dict)
            sugg_interval_cols = ['Sugg Interval Backtest 1', 'Sugg Interval Backtest 2', 'Sugg Interval Backtest 3', 'Sugg Interval Backtest 4']
            df_forecast[sugg_interval_cols] = df_forecast[sugg_interval_cols].fillna('Point')
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecast


    def compute_suggested_interval(self, df_forecast, backtest_names):
        """
        Return a dataframe attaching the suggested interval per date and item record

        :param df_forecast: Original dataframe including all items' forecasts
        :param backtest_names: List of backtests names to concat, e.g. alpha, beta, gamma, delta and eps
        :param datalake_path_: Datalake path to download the backtest files from. Do not include bucket name
        :return df_forecast: Output forecast dataframe including sugguested interval

        >>> df = compute_suggested_interval(df_forecast, backtest_names=['alpha', 'beta'])
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        suggested_interval = []
        num_backtests = len(backtest_names)
        try:
            for ixr, row in df_forecast.iterrows():
                acc_point, acc_lo95, acc_lo80, acc_lo60, acc_up60, acc_up80, acc_up95 = 0, 0, 0, 0, 0, 0, 0
                for backtest in range(1, num_backtests + 1):
                    backtest_factor = num_backtests / backtest
                    if row['Sugg Interval Backtest ' + str(backtest)] == 'Point':
                        acc_point += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo95':
                        acc_lo95 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo80':
                        acc_lo80 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo60':
                        acc_lo60 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up60':
                        acc_up60 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up80':
                        acc_up80 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up95':
                        acc_up95 += backtest_factor
                suggested_interval_dict = {'Point': acc_point,
                                          'Lo95': acc_lo95,
                                          'Lo80': acc_lo80,
                                          'Lo60': acc_lo60,
                                          'Up60': acc_up60,
                                          'Up80': acc_up80,
                                          'Up95': acc_up95
                                          }
                suggested_interval.append(max(suggested_interval_dict, key=suggested_interval_dict.get))
            df_forecast['Suggested Interval'] = suggested_interval
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecast


    def compute_suggested_forecast(self, df_forecast, backtest_names):
        """
        Return a dataframe attaching the suggested interval per date and item record

        :param df_forecast: Original dataframe including all items' forecasts
        :param backtest_names: List of backtests names to concat, e.g. alpha, beta, gamma, delta and eps
        :param datalake_path_: Datalake path to download the backtest files from. Do not include bucket name
        :return df_forecast: Output forecast dataframe including sugguested interval

        >>> df = compute_suggested_forecast(df_forecast, backtest_names=['alpha', 'beta'])
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        suggested_interval, suggested_forecast = [], []
        num_backtests = len(backtest_names)
        try:
            for ixr, row in df_forecast.iterrows():
                acc_point, acc_lo95, acc_lo80, acc_lo60, acc_up60, acc_up80, acc_up95 = 0, 0, 0, 0, 0, 0, 0
                for backtest in range(1, num_backtests + 1):
                    backtest_factor = num_backtests / backtest
                    if row['Sugg Interval Backtest ' + str(backtest)] == 'Point':
                        acc_point += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo95':
                        acc_lo95 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo80':
                        acc_lo80 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Lo60':
                        acc_lo60 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up60':
                        acc_up60 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up80':
                        acc_up80 += backtest_factor
                    elif row['Sugg Interval Backtest ' + str(backtest)] == 'Up95':
                        acc_up95 += backtest_factor
                suggested_interval_dict = {'Point': acc_point,
                                          'Lo95': acc_lo95,
                                          'Lo80': acc_lo80,
                                          'Lo60': acc_lo60,
                                          'Up60': acc_up60,
                                          'Up80': acc_up80,
                                          'Up95': acc_up95
                                          }
                suggested_interval.append(max(suggested_interval_dict, key=suggested_interval_dict.get))
                suggested_forecast.append(row['Forecast ' + max(suggested_interval_dict, key=suggested_interval_dict.get)])
            df_forecast['Suggested Forecast'] = suggested_forecast
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecast


    def concat_forecast_backtests(self, df_forecast, df_backtest):
        """
        Return a dataframe attaching forecast and backtests records

        :param df_forecast: Original dataframe including all items' forecasts
        :param df_backtest: Dataframe including all items' backtests
        :return df_forecast: Output forecast dataframe attaching all backtests

        >>> df = concat_forecast_backtests(df_forecast, df_backtest)
        >>> df =
                        var1    var2    var3
                idx0     1       2       3
        """
        try:
            df_forecast = pd.concat([df_forecast, df_backtest[df_forecast.columns]], axis='rows')
        except KeyError as err:
            self.logger.exception(f'Invalid column name. Please check dataframe metadata: {err}')
            raise
        return df_forecast

