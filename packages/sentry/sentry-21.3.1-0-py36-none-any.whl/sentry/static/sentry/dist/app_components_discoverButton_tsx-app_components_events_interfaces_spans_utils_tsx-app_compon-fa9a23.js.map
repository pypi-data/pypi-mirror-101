{"version":3,"sources":["webpack:///./app/components/discoverButton.tsx","webpack:///./app/components/events/interfaces/spans/utils.tsx","webpack:///./app/components/notAvailable.tsx","webpack:///./app/components/sentryDocumentTitle.tsx","webpack:///./app/utils/discover/discoverQuery.tsx","webpack:///./app/utils/performance/vitals/constants.tsx","webpack:///./app/views/performance/transactionSummary/utils.tsx"],"names":["DiscoverButton","children","buttonProps","noFeatureMessage","t","hookName","features","renderDisabled","p","body","hideHelpToggle","message","featureName","hasFeature","disabled","TimestampStatus","rectOfContent","element","getBoundingClientRect","left","top","x","window","pageXOffset","y","pageYOffset","getOffsetOfElement","clientLeft","scrollLeft","clientTop","scrollTop","width","scrollWidth","height","scrollHeight","clamp","value","min","max","toPercent","toFixed","normalizeTimestamps","spanBounds","startTimestamp","endTimestamp","boundsGenerator","bounds","viewStart","viewEnd","traceStartTimestamp","traceEndTimestamp","traceDuration","viewStartTimestamp","viewDuration","type","isSpanVisibleInView","timestampStatus","Stable","Equal","Reversed","parseSpanTimestamps","start","end","getHumanDuration","duration","toLocaleString","undefined","minimumFractionDigits","maximumFractionDigits","getLetterIndex","letter","index","indexOf","colorsAsArray","Object","keys","CHART_PALETTE","map","key","spanColors","default","transaction","http","db","pickSpanBarColour","input","length","letterIndex1","slice","letterIndex2","letterIndex3","generateRootSpan","trace","trace_id","traceID","span_id","rootSpanID","parent_span_id","parentSpanID","start_timestamp","timestamp","op","description","data","status","rootSpanStatus","getTraceDateTimeRange","moment","subtract","utc","format","add","isGapSpan","span","isOrphanSpan","isOrphan","getSpanID","defaultSpanID","getSpanOperation","getSpanTraceID","getTraceContext","event","contexts","parseTrace","spanEntry","entries","find","entry","EntryType","spans","traceContext","rootSpanOpName","childSpans","numOfSpans","potentialParents","Set","init","reduced","reduce","acc","inputSpan","maybeSpanID","parentSpanId","getSpanParentSpanID","hasParent","has","isString","assert","spanChildren","push","set","hasEndTimestamp","isNumber","values","forEach","sort","sortSpans","firstSpan","secondSpan","isOrphanTreeDepth","treeDepth","unwrapTreeDepth","depth","isEventFromBrowserJavaScriptSDK","sdkName","sdk","name","includes","toLowerCase","durationlessBrowserOps","hasFailedThreshold","marks","names","WEB_VITAL_DETAILS","filter","vital","slug","some","record","poorThreshold","getMeasurements","measurements","Map","startsWith","associatedMeasurement","mergedMeasurements","measurement","verticalMark","get","failedThreshold","getMeasurementBounds","generateBounds","warning","NotAvailable","tooltip","Wrapper","title","defined","theme","gray200","SentryDocumentTitle","orgSlug","projectSlug","docTitle","DiscoverQuery","props","route","withApi","WebVital","acronym","measurementType","TransactionFilterOptions","transactionSummaryRouteWithQuery","projectID","query","unselectedSeries","display","trendFunction","trendColumn","showTransactions","pathname","project","environment","statsPeriod","SidebarSpacer","space"],"mappings":"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","file":"app_components_discoverButton_tsx-app_components_events_interfaces_spans_utils_tsx-app_compon-fa9a23.js","sourcesContent":["import React from 'react';\n\nimport Feature from 'app/components/acl/feature';\nimport FeatureDisabled from 'app/components/acl/featureDisabled';\nimport Button from 'app/components/button';\nimport Hovercard from 'app/components/hovercard';\nimport {t} from 'app/locale';\n\ntype Props = React.PropsWithChildren<{\n  className?: string;\n}> &\n  React.ComponentProps<typeof Button>;\n\n/**\n * Provide a button that turns itself off if the current organization\n * doesn't have access to discover results.\n */\nfunction DiscoverButton({children, ...buttonProps}: Props) {\n  const noFeatureMessage = t('Requires discover feature.');\n\n  const renderDisabled = p => (\n    <Hovercard\n      body={\n        <FeatureDisabled\n          features={p.features}\n          hideHelpToggle\n          message={noFeatureMessage}\n          featureName={noFeatureMessage}\n        />\n      }\n    >\n      {p.children(p)}\n    </Hovercard>\n  );\n\n  return (\n    <Feature\n      hookName=\"feature-disabled:open-discover\"\n      features={['organizations:discover-basic']}\n      renderDisabled={renderDisabled}\n    >\n      {({hasFeature}) => (\n        <Button disabled={!hasFeature} {...buttonProps}>\n          {children}\n        </Button>\n      )}\n    </Feature>\n  );\n}\n\nexport default DiscoverButton;\n","import isNumber from 'lodash/isNumber';\nimport isString from 'lodash/isString';\nimport set from 'lodash/set';\nimport moment from 'moment';\n\nimport CHART_PALETTE from 'app/constants/chartPalette';\nimport {EntryType, EventTransaction} from 'app/types/event';\nimport {assert} from 'app/types/utils';\nimport {WEB_VITAL_DETAILS} from 'app/utils/performance/vitals/constants';\n\nimport {\n  GapSpanType,\n  OrphanSpanType,\n  OrphanTreeDepth,\n  ParsedTraceType,\n  ProcessedSpanType,\n  RawSpanType,\n  SpanEntry,\n  SpanType,\n  TraceContextType,\n  TreeDepthType,\n} from './types';\n\ntype Rect = {\n  // x and y are left/top coords respectively\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\n// get position of element relative to top/left of document\nconst getOffsetOfElement = (element: Element) => {\n  // left and top are relative to viewport\n  const {left, top} = element.getBoundingClientRect();\n\n  // get values that the document is currently scrolled by\n  const scrollLeft = window.pageXOffset;\n  const scrollTop = window.pageYOffset;\n\n  return {x: left + scrollLeft, y: top + scrollTop};\n};\n\nexport const rectOfContent = (element: Element): Rect => {\n  const {x, y} = getOffsetOfElement(element);\n\n  // offsets for the border and any scrollbars (clientLeft and clientTop),\n  // and if the element was scrolled (scrollLeft and scrollTop)\n  //\n  // NOTE: clientLeft and clientTop does not account for any margins nor padding\n  const contentOffsetLeft = element.clientLeft - element.scrollLeft;\n  const contentOffsetTop = element.clientTop - element.scrollTop;\n\n  return {\n    x: x + contentOffsetLeft,\n    y: y + contentOffsetTop,\n    width: element.scrollWidth,\n    height: element.scrollHeight,\n  };\n};\n\nexport const rectOfViewport = (): Rect => ({\n  x: window.pageXOffset,\n  y: window.pageYOffset,\n  width: window.document.documentElement.clientWidth,\n  height: window.document.documentElement.clientHeight,\n});\n\nexport const rectRelativeTo = (rect: Rect, pos = {x: 0, y: 0}): Rect => ({\n  x: rect.x - pos.x,\n  y: rect.y - pos.y,\n  width: rect.width,\n  height: rect.height,\n});\n\nexport const rectOfElement = (element: HTMLElement): Rect => {\n  const {x, y} = getOffsetOfElement(element);\n  return {\n    x,\n    y,\n    width: element.offsetWidth,\n    height: element.offsetHeight,\n  };\n};\n\nexport const clamp = (value: number, min: number, max: number): number => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\n\nexport const isValidSpanID = (maybeSpanID: any) =>\n  isString(maybeSpanID) && maybeSpanID.length > 0;\n\nexport const toPercent = (value: number) => `${(value * 100).toFixed(3)}%`;\n\nexport type SpanBoundsType = {startTimestamp: number; endTimestamp: number};\nexport type SpanGeneratedBoundsType =\n  | {type: 'TRACE_TIMESTAMPS_EQUAL'; isSpanVisibleInView: boolean}\n  | {type: 'INVALID_VIEW_WINDOW'; isSpanVisibleInView: boolean}\n  | {\n      type: 'TIMESTAMPS_EQUAL';\n      start: number;\n      width: number;\n      isSpanVisibleInView: boolean;\n    }\n  | {\n      type: 'TIMESTAMPS_REVERSED';\n      start: number;\n      end: number;\n      isSpanVisibleInView: boolean;\n    }\n  | {\n      type: 'TIMESTAMPS_STABLE';\n      start: number;\n      end: number;\n      isSpanVisibleInView: boolean;\n    };\n\nexport type SpanViewBoundsType = {\n  warning: undefined | string;\n  left: undefined | number;\n  width: undefined | number;\n  isSpanVisibleInView: boolean;\n};\n\nconst normalizeTimestamps = (spanBounds: SpanBoundsType): SpanBoundsType => {\n  const {startTimestamp, endTimestamp} = spanBounds;\n\n  if (startTimestamp > endTimestamp) {\n    return {startTimestamp: endTimestamp, endTimestamp: startTimestamp};\n  }\n\n  return spanBounds;\n};\n\nexport enum TimestampStatus {\n  Stable,\n  Reversed,\n  Equal,\n}\n\nexport const parseSpanTimestamps = (spanBounds: SpanBoundsType): TimestampStatus => {\n  const startTimestamp: number = spanBounds.startTimestamp;\n  const endTimestamp: number = spanBounds.endTimestamp;\n\n  if (startTimestamp < endTimestamp) {\n    return TimestampStatus.Stable;\n  }\n\n  if (startTimestamp === endTimestamp) {\n    return TimestampStatus.Equal;\n  }\n\n  return TimestampStatus.Reversed;\n};\n\n// given the start and end trace timestamps, and the view window, we want to generate a function\n// that'll output the relative %'s for the width and placements relative to the left-hand side.\n//\n// The view window (viewStart and viewEnd) are percentage values (between 0% and 100%), they correspond to the window placement\n// between the start and end trace timestamps.\nexport const boundsGenerator = (bounds: {\n  traceStartTimestamp: number; // unix timestamp\n  traceEndTimestamp: number; // unix timestamp\n  viewStart: number; // in [0, 1]\n  viewEnd: number; // in [0, 1]\n}) => {\n  const {viewStart, viewEnd} = bounds;\n\n  const {\n    startTimestamp: traceStartTimestamp,\n    endTimestamp: traceEndTimestamp,\n  } = normalizeTimestamps({\n    startTimestamp: bounds.traceStartTimestamp,\n    endTimestamp: bounds.traceEndTimestamp,\n  });\n\n  // viewStart and viewEnd are percentage values (%) of the view window relative to the left\n  // side of the trace view minimap\n\n  // invariant: viewStart <= viewEnd\n\n  // duration of the entire trace in seconds\n  const traceDuration = traceEndTimestamp - traceStartTimestamp;\n\n  const viewStartTimestamp = traceStartTimestamp + viewStart * traceDuration;\n  const viewEndTimestamp = traceEndTimestamp - (1 - viewEnd) * traceDuration;\n  const viewDuration = viewEndTimestamp - viewStartTimestamp;\n\n  return (spanBounds: SpanBoundsType): SpanGeneratedBoundsType => {\n    // TODO: alberto.... refactor so this is impossible ðŸ˜ \n    if (traceDuration <= 0) {\n      return {\n        type: 'TRACE_TIMESTAMPS_EQUAL',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    if (viewDuration <= 0) {\n      return {\n        type: 'INVALID_VIEW_WINDOW',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    const {startTimestamp, endTimestamp} = normalizeTimestamps(spanBounds);\n\n    const timestampStatus = parseSpanTimestamps(spanBounds);\n\n    const start = (startTimestamp - viewStartTimestamp) / viewDuration;\n    const end = (endTimestamp - viewStartTimestamp) / viewDuration;\n\n    const isSpanVisibleInView = end > 0 && start < 1;\n\n    switch (timestampStatus) {\n      case TimestampStatus.Equal: {\n        return {\n          type: 'TIMESTAMPS_EQUAL',\n          start,\n          width: 1,\n          // a span bar is visible even if they're at the extreme ends of the view selection.\n          // these edge cases are:\n          // start == end == 0, and\n          // start == end == 1\n          isSpanVisibleInView: end >= 0 && start <= 1,\n        };\n      }\n      case TimestampStatus.Reversed: {\n        return {\n          type: 'TIMESTAMPS_REVERSED',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      case TimestampStatus.Stable: {\n        return {\n          type: 'TIMESTAMPS_STABLE',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      default: {\n        const _exhaustiveCheck: never = timestampStatus;\n        return _exhaustiveCheck;\n      }\n    }\n  };\n};\n\nexport const getHumanDuration = (duration: number): string => {\n  // note: duration is assumed to be in seconds\n\n  const durationMS = duration * 1000;\n  return `${durationMS.toLocaleString(undefined, {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  })}ms`;\n};\n\nconst getLetterIndex = (letter: string): number => {\n  const index = 'abcdefghijklmnopqrstuvwxyz'.indexOf(letter) || 0;\n  return index === -1 ? 0 : index;\n};\n\nconst colorsAsArray = Object.keys(CHART_PALETTE).map(key => CHART_PALETTE[17][key]);\n\nexport const spanColors = {\n  default: CHART_PALETTE[17][4],\n  transaction: CHART_PALETTE[17][8],\n  http: CHART_PALETTE[17][10],\n  db: CHART_PALETTE[17][17],\n};\n\nexport const pickSpanBarColour = (input: string | undefined): string => {\n  // We pick the color for span bars using the first three letters of the op name.\n  // That way colors stay consistent between transactions.\n\n  if (!input || input.length < 3) {\n    return CHART_PALETTE[17][4];\n  }\n\n  if (spanColors[input]) {\n    return spanColors[input];\n  }\n\n  const letterIndex1 = getLetterIndex(input.slice(0, 1));\n  const letterIndex2 = getLetterIndex(input.slice(1, 2));\n  const letterIndex3 = getLetterIndex(input.slice(2, 3));\n\n  return colorsAsArray[\n    (letterIndex1 + letterIndex2 + letterIndex3) % colorsAsArray.length\n  ];\n};\n\nexport function generateRootSpan(trace: ParsedTraceType): RawSpanType {\n  const rootSpan: RawSpanType = {\n    trace_id: trace.traceID,\n    span_id: trace.rootSpanID,\n    parent_span_id: trace.parentSpanID,\n    start_timestamp: trace.traceStartTimestamp,\n    timestamp: trace.traceEndTimestamp,\n    op: trace.op,\n    description: trace.description,\n    data: {},\n    status: trace.rootSpanStatus,\n  };\n\n  return rootSpan;\n}\n\n// start and end are assumed to be unix timestamps with fractional seconds\nexport function getTraceDateTimeRange(input: {\n  start: number;\n  end: number;\n}): {start: string; end: string} {\n  const start = moment\n    .unix(input.start)\n    .subtract(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  const end = moment\n    .unix(input.end)\n    .add(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  return {\n    start,\n    end,\n  };\n}\n\nexport function isGapSpan(span: ProcessedSpanType): span is GapSpanType {\n  if ('type' in span) {\n    return span.type === 'gap';\n  }\n\n  return false;\n}\n\nexport function isOrphanSpan(span: ProcessedSpanType): span is OrphanSpanType {\n  if ('type' in span) {\n    if (span.type === 'orphan') {\n      return true;\n    }\n\n    if (span.type === 'gap') {\n      return span.isOrphan;\n    }\n  }\n\n  return false;\n}\n\nexport function getSpanID(span: ProcessedSpanType, defaultSpanID: string = ''): string {\n  if (isGapSpan(span)) {\n    return defaultSpanID;\n  }\n\n  return span.span_id;\n}\n\nexport function getSpanOperation(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return undefined;\n  }\n\n  return span.op;\n}\n\nexport function getSpanTraceID(span: ProcessedSpanType): string {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.trace_id;\n}\n\nexport function getSpanParentSpanID(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.parent_span_id;\n}\n\nexport function getTraceContext(\n  event: Readonly<EventTransaction>\n): TraceContextType | undefined {\n  return event?.contexts?.trace;\n}\n\nexport function parseTrace(event: Readonly<EventTransaction>): ParsedTraceType {\n  const spanEntry = event.entries.find((entry: SpanEntry | any): entry is SpanEntry => {\n    return entry.type === EntryType.SPANS;\n  });\n\n  const spans: Array<RawSpanType> = spanEntry?.data ?? [];\n\n  const traceContext = getTraceContext(event);\n  const traceID = (traceContext && traceContext.trace_id) || '';\n  const rootSpanID = (traceContext && traceContext.span_id) || '';\n  const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';\n  const description = traceContext && traceContext.description;\n  const parentSpanID = traceContext && traceContext.parent_span_id;\n  const rootSpanStatus = traceContext && traceContext.status;\n\n  if (!spanEntry || spans.length <= 0) {\n    return {\n      op: rootSpanOpName,\n      childSpans: {},\n      traceStartTimestamp: event.startTimestamp,\n      traceEndTimestamp: event.endTimestamp,\n      traceID,\n      rootSpanID,\n      rootSpanStatus,\n      parentSpanID,\n      numOfSpans: 0,\n      spans: [],\n      description,\n    };\n  }\n\n  // any span may be a parent of another span\n  const potentialParents = new Set(\n    spans.map(span => {\n      return span.span_id;\n    })\n  );\n\n  // the root transaction span is a parent of all other spans\n  potentialParents.add(rootSpanID);\n\n  // we reduce spans to become an object mapping span ids to their children\n\n  const init: ParsedTraceType = {\n    op: rootSpanOpName,\n    childSpans: {},\n    traceStartTimestamp: event.startTimestamp,\n    traceEndTimestamp: event.endTimestamp,\n    traceID,\n    rootSpanID,\n    rootSpanStatus,\n    parentSpanID,\n    numOfSpans: spans.length,\n    spans,\n    description,\n  };\n\n  const reduced: ParsedTraceType = spans.reduce((acc, inputSpan) => {\n    let span: SpanType = inputSpan;\n\n    const parentSpanId = getSpanParentSpanID(span);\n\n    const hasParent = parentSpanId && potentialParents.has(parentSpanId);\n\n    if (!isValidSpanID(parentSpanId) || !hasParent) {\n      // this span is considered an orphan with respect to the spans within this transaction.\n      // although the span is an orphan, it's still a descendant of this transaction,\n      // so we set its parent span id to be the root transaction span's id\n      span.parent_span_id = rootSpanID;\n\n      span = {\n        type: 'orphan',\n        ...span,\n      } as OrphanSpanType;\n    }\n\n    assert(span.parent_span_id);\n\n    // get any span children whose parent_span_id is equal to span.parent_span_id,\n    // otherwise start with an empty array\n    const spanChildren: Array<SpanType> = acc.childSpans[span.parent_span_id] ?? [];\n\n    spanChildren.push(span);\n\n    set(acc.childSpans, span.parent_span_id, spanChildren);\n\n    // set trace start & end timestamps based on given span's start and end timestamps\n\n    if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {\n      acc.traceStartTimestamp = span.start_timestamp;\n    }\n\n    // establish trace end timestamp\n\n    const hasEndTimestamp = isNumber(span.timestamp);\n\n    if (!acc.traceEndTimestamp) {\n      if (hasEndTimestamp) {\n        acc.traceEndTimestamp = span.timestamp;\n        return acc;\n      }\n\n      acc.traceEndTimestamp = span.start_timestamp;\n      return acc;\n    }\n\n    if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.timestamp;\n      return acc;\n    }\n\n    if (span.start_timestamp > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.start_timestamp;\n    }\n\n    return acc;\n  }, init);\n\n  // sort span children\n\n  Object.values(reduced.childSpans).forEach(spanChildren => {\n    spanChildren.sort(sortSpans);\n  });\n\n  return reduced;\n}\n\nfunction sortSpans(firstSpan: SpanType, secondSpan: SpanType) {\n  // orphan spans come after non-orphan spans.\n\n  if (isOrphanSpan(firstSpan) && !isOrphanSpan(secondSpan)) {\n    // sort secondSpan before firstSpan\n    return 1;\n  }\n\n  if (!isOrphanSpan(firstSpan) && isOrphanSpan(secondSpan)) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  // sort spans by their start timestamp in ascending order\n\n  if (firstSpan.start_timestamp < secondSpan.start_timestamp) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  if (firstSpan.start_timestamp === secondSpan.start_timestamp) {\n    return 0;\n  }\n\n  // sort secondSpan before firstSpan\n  return 1;\n}\n\nexport function isOrphanTreeDepth(\n  treeDepth: TreeDepthType\n): treeDepth is OrphanTreeDepth {\n  if (typeof treeDepth === 'number') {\n    return false;\n  }\n  return treeDepth?.type === 'orphan';\n}\n\nexport function unwrapTreeDepth(treeDepth: TreeDepthType): number {\n  if (isOrphanTreeDepth(treeDepth)) {\n    return treeDepth.depth;\n  }\n\n  return treeDepth;\n}\n\nexport function isEventFromBrowserJavaScriptSDK(event: EventTransaction): boolean {\n  const sdkName = event.sdk?.name;\n  if (!sdkName) {\n    return false;\n  }\n  // based on https://github.com/getsentry/sentry-javascript/blob/master/packages/browser/src/version.ts\n  return [\n    'sentry.javascript.browser',\n    'sentry.javascript.react',\n    'sentry.javascript.gatsby',\n    'sentry.javascript.ember',\n    'sentry.javascript.vue',\n    'sentry.javascript.angular',\n  ].includes(sdkName.toLowerCase());\n}\n\n// Durationless ops from: https://github.com/getsentry/sentry-javascript/blob/0defcdcc2dfe719343efc359d58c3f90743da2cd/packages/apm/src/integrations/tracing.ts#L629-L688\n// PerformanceMark: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformanceMark\n// PerformancePaintTiming: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformancePaintTiming\nexport const durationlessBrowserOps = ['mark', 'paint'];\n\ntype Measurements = {\n  [name: string]: number | undefined;\n};\n\ntype VerticalMark = {\n  marks: Measurements;\n  failedThreshold: boolean;\n};\n\nfunction hasFailedThreshold(marks: Measurements): boolean {\n  const names = Object.keys(marks);\n  const records = Object.values(WEB_VITAL_DETAILS).filter(vital =>\n    names.includes(vital.slug)\n  );\n\n  return records.some(record => {\n    const value = marks[record.slug];\n    if (typeof value === 'number') {\n      return value >= record.poorThreshold;\n    }\n    return false;\n  });\n}\n\nexport function getMeasurements(event: EventTransaction): Map<number, VerticalMark> {\n  if (!event.measurements) {\n    return new Map();\n  }\n\n  const measurements = Object.keys(event.measurements)\n    .filter(name => name.startsWith('mark.'))\n    .map(name => {\n      const slug = name.slice('mark.'.length);\n      const associatedMeasurement = event.measurements![slug];\n      return {\n        name,\n        timestamp: event.measurements![name].value,\n        value: associatedMeasurement ? associatedMeasurement.value : undefined,\n      };\n    });\n\n  const mergedMeasurements = new Map<number, VerticalMark>();\n\n  measurements.forEach(measurement => {\n    const name = measurement.name.slice('mark.'.length);\n    const value = measurement.value;\n\n    if (mergedMeasurements.has(measurement.timestamp)) {\n      const verticalMark = mergedMeasurements.get(measurement.timestamp) as VerticalMark;\n\n      verticalMark.marks = {\n        ...verticalMark.marks,\n        [name]: value,\n      };\n\n      if (!verticalMark.failedThreshold) {\n        verticalMark.failedThreshold = hasFailedThreshold(verticalMark.marks);\n      }\n\n      mergedMeasurements.set(measurement.timestamp, verticalMark);\n      return;\n    }\n\n    const marks = {\n      [name]: value,\n    };\n\n    mergedMeasurements.set(measurement.timestamp, {\n      marks,\n      failedThreshold: hasFailedThreshold(marks),\n    });\n  });\n\n  return mergedMeasurements;\n}\n\nexport function getMeasurementBounds(\n  timestamp: number,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const bounds = generateBounds({\n    startTimestamp: timestamp,\n    endTimestamp: timestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: undefined,\n        left: undefined,\n        width: undefined,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport Tooltip from 'app/components/tooltip';\nimport {defined} from 'app/utils';\n\ntype Props = {\n  tooltip?: React.ReactNode;\n};\n\nfunction NotAvailable({tooltip}: Props) {\n  return (\n    <Wrapper>\n      <Tooltip title={tooltip} disabled={!defined(tooltip)}>\n        {'\\u2014'}\n      </Tooltip>\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled('div')`\n  color: ${p => p.theme.gray200};\n`;\n\nexport default NotAvailable;\n","import React from 'react';\nimport DocumentTitle from 'react-document-title';\n\ntype Props = {\n  // Main page title\n  title: string;\n  orgSlug?: string;\n  projectSlug?: string;\n  children?: React.ReactNode;\n};\n\nfunction SentryDocumentTitle({title, orgSlug, projectSlug, children}: Props) {\n  function getDocTitle() {\n    if (!orgSlug && !projectSlug) {\n      return title;\n    }\n\n    if (orgSlug && projectSlug) {\n      return `${title} - ${orgSlug} - ${projectSlug}`;\n    }\n\n    if (orgSlug) {\n      return `${title} - ${orgSlug}`;\n    }\n\n    return `${title} - ${projectSlug}`;\n  }\n\n  const docTitle = getDocTitle();\n\n  return <DocumentTitle title={`${docTitle} - Sentry`}>{children}</DocumentTitle>;\n}\n\nexport default SentryDocumentTitle;\n","import React from 'react';\n\nimport {MetaType} from 'app/utils/discover/eventView';\nimport withApi from 'app/utils/withApi';\n\nimport GenericDiscoverQuery, {DiscoverQueryProps} from './genericDiscoverQuery';\n\n/**\n * An individual row in a DiscoverQuery result\n */\nexport type TableDataRow = {\n  id: string;\n  [key: string]: React.ReactText;\n};\n\n/**\n * A DiscoverQuery result including rows and metadata.\n */\nexport type TableData = {\n  data: Array<TableDataRow>;\n  meta?: MetaType;\n};\n\nfunction DiscoverQuery(props: DiscoverQueryProps) {\n  return <GenericDiscoverQuery<TableData, {}> route=\"eventsv2\" {...props} />;\n}\n\nexport default withApi(DiscoverQuery);\n","import {t} from 'app/locale';\nimport {measurementType, WebVital} from 'app/utils/discover/fields';\nimport {Vital} from 'app/utils/performance/vitals/types';\n\nexport const WEB_VITAL_DETAILS: Record<WebVital, Vital> = {\n  [WebVital.FP]: {\n    slug: 'fp',\n    name: t('First Paint'),\n    acronym: 'FP',\n    description: t(\n      'Render time of the first pixel loaded in the viewport (may overlap with FCP).'\n    ),\n    poorThreshold: 3000,\n    type: measurementType(WebVital.FP),\n  },\n  [WebVital.FCP]: {\n    slug: 'fcp',\n    name: t('First Contentful Paint'),\n    acronym: 'FCP',\n    description: t(\n      'Render time of the first image, text or other DOM node in the viewport.'\n    ),\n    poorThreshold: 3000,\n    type: measurementType(WebVital.FCP),\n  },\n  [WebVital.LCP]: {\n    slug: 'lcp',\n    name: t('Largest Contentful Paint'),\n    acronym: 'LCP',\n    description: t(\n      'Render time of the largest image, text or other DOM node in the viewport.'\n    ),\n    poorThreshold: 4000,\n    type: measurementType(WebVital.LCP),\n  },\n  [WebVital.FID]: {\n    slug: 'fid',\n    name: t('First Input Delay'),\n    acronym: 'FID',\n    description: t(\n      'Response time of the browser to a user interaction (clicking, tapping, etc).'\n    ),\n    poorThreshold: 300,\n    type: measurementType(WebVital.FID),\n  },\n  [WebVital.CLS]: {\n    slug: 'cls',\n    name: t('Cumulative Layout Shift'),\n    acronym: 'CLS',\n    description: t(\n      'Sum of layout shift scores that measure the visual stability of the page.'\n    ),\n    poorThreshold: 0.25,\n    type: measurementType(WebVital.CLS),\n  },\n  [WebVital.TTFB]: {\n    slug: 'ttfb',\n    name: t('Time to First Byte'),\n    acronym: 'TTFB',\n    description: t(\n      \"The time that it takes for a user's browser to receive the first byte of page content.\"\n    ),\n    poorThreshold: 600,\n    type: measurementType(WebVital.TTFB),\n  },\n  [WebVital.RequestTime]: {\n    slug: 'ttfb.requesttime',\n    name: t('Request Time'),\n    acronym: 'RT',\n    description: t(\n      'Captures the time spent making the request and receiving the first byte of the response.'\n    ),\n    poorThreshold: 600,\n    type: measurementType(WebVital.RequestTime),\n  },\n};\n","import styled from '@emotion/styled';\nimport {Query} from 'history';\n\nimport space from 'app/styles/space';\n\nimport {DisplayModes} from './charts';\n\nexport enum TransactionFilterOptions {\n  FASTEST = 'fastest',\n  SLOW = 'slow',\n  OUTLIER = 'outlier',\n  RECENT = 'recent',\n}\n\nexport function generateTransactionSummaryRoute({orgSlug}: {orgSlug: String}): string {\n  return `/organizations/${orgSlug}/performance/summary/`;\n}\n\nexport function transactionSummaryRouteWithQuery({\n  orgSlug,\n  transaction,\n  projectID,\n  query,\n  unselectedSeries = 'p100()',\n  display,\n  trendFunction,\n  trendColumn,\n  showTransactions,\n}: {\n  orgSlug: string;\n  transaction: string;\n  query: Query;\n  display?: DisplayModes;\n  trendFunction?: string;\n  trendColumn?: string;\n  unselectedSeries?: string | string[];\n  projectID?: string | string[];\n  showTransactions?: TransactionFilterOptions;\n}) {\n  const pathname = generateTransactionSummaryRoute({\n    orgSlug,\n  });\n\n  return {\n    pathname,\n    query: {\n      transaction,\n      project: projectID,\n      environment: query.environment,\n      statsPeriod: query.statsPeriod,\n      start: query.start,\n      end: query.end,\n      query: query.query,\n      unselectedSeries,\n      showTransactions,\n      display,\n      trendFunction,\n      trendColumn,\n    },\n  };\n}\n\nexport const SidebarSpacer = styled('div')`\n  margin-top: ${space(3)};\n`;\n"],"sourceRoot":""}