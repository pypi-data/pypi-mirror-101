# -*- coding: utf-8 -*-
"""Untitled101.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l6AunBE4VUQEOVtq3DGVsJrzLMhkx0YR
"""

from collections import defaultdict
from sklearn.cluster import KMeans
from sklearn.feature_extraction.text import TfidfTransformer
from sklearn.pipeline import Pipeline
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from scipy import sparse
from numpy import linalg as LA


class domain2vec:
    def __init__(self, embedding, k):
        self.embedding=embedding
        self.k=k
        self.cluster_vocab = []
        self.vocab = defaultdict(int)
        self.idf_dict = defaultdict(float)
        self.matrix=[]
        self.culster_corpus = []

    def fit_transform(self, corpus):
        
        self.corpus = corpus
        self.vocabulary()
        self.em_matrix()
        self.tranform_cluster()
        self.idf()

        ln = len(self.corpus)
        matrix = np.zeros((ln, self.k))
        print('matrix generation ..... ')
        for i in range(0, ln):
            if i%100==0:
                print(i)
            temp= self.corpus[i].split()
            ln_temp=len(temp)

            sim_cnt=0
            for j in range(0,ln_temp):
                emb=self.embedding[temp[j]]
                p=self.cluster.predict([list(emb)])[0]
                cos = cosine_similarity([emb],[self.center[p]])
                sim_value = 1/(np.exp(1- cos[0][0]))
                sim_value = 1/(np.exp(1- sim_value))
                sim_cnt+=sim_value
                rel = sim_value * self.id_f[p]
           
                matrix[i][p]+=(rel)

            matrix[i]=matrix[i]/max(sim_cnt, 0.000000001)
            norm = LA.norm(matrix[i])

            if norm>0.0:
                matrix[i]=matrix[i]/norm
       
            
                #print(cos,p, emb, self.center[p])
                #print(temp[j], matrix[i][p])

        return matrix

     

    def fit(self, corpus):

        self.corpus = corpus
        self.vocabulary()
        self.em_matrix()
        self.tranform_cluster()
        self.idf()

    def vocabulary(self):
        
        print('Generating vocab....')

        def add_word(word):
            self.vocab[word]+=1
        [add_word(w) for sent in self.corpus for w in sent.split()]

        return self.vocab.keys()

 
    def em_matrix(self):
        
        print('Developing embedding matrics.....')
        for key in self.vocab.keys():
            self.matrix.append(list(self.embedding[key]))

        return self.matrix


    def tranform_cluster(self):
        
        print('clustering....')
        
        [self.cluster_vocab.append('cluster'+str(i)) for i in range(0, self.k)]
        self.cluster = KMeans(n_clusters = self.k).fit(self.matrix)
        self.center = self.cluster.cluster_centers_

        print('cluster transfer .. ')

        for sent in self.corpus:
            #temp=self.sent.split()
            st = ''
            for w in sent.split():
                #self.corpus[sent][w] = self.cluster.predict([list(self.embedding[self.corpus[sent][w]])])[0]
                p=self.cluster.predict([list(self.embedding[w])])[0]
                st= st+' '+'cluster'+ str(p)

            self.culster_corpus.append(st.strip())
                
        #print(self.culster_corpus)
        return self.culster_corpus


    def idf(self):
        print('idf developing... ')

        pipe = Pipeline([('count', CountVectorizer(vocabulary=self.cluster_vocab)),('tfid', TfidfTransformer())]).fit(self.culster_corpus)
        self.id_f = pipe['tfid'].idf_
        #print( self.id_f)


    def transform(self, data):
        
        ln = len(data)
        matrix = np.zeros((ln, self.k))

        for i in range(0, ln):
            temp= data[i].split()
            ln_temp=len(temp)
        
            sim_cnt=0
            for j in range(0,ln_temp):
                emb=self.embedding[temp[j]]
                p=self.cluster.predict([list(emb)])[0]
                cos = cosine_similarity([emb],[self.center[p]])
                sim_value = 1/(np.exp(1- cos[0][0]))
                sim_value = 1/(np.exp(1- sim_value))
                rel = sim_value * self.id_f[p]

                matrix[i][p]+=(rel)
                sim_cnt+=sim_value

            matrix[i]=matrix[i]/max(sim_cnt, 0.000000001)
            norm = LA.norm(matrix[i])

            if norm>0.0:
                matrix[i]=matrix[i]/norm


                #print(cos,p, emb, self.center[p])
                #print(temp[j], matrix[i][p])

        return matrix
                                
            
       
    
    #def transform (self):