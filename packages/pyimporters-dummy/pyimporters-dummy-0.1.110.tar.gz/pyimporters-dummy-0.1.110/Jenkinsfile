pipeline {
  environment {
    PYTHONDONTWRITEBYTECODE="1"
    PYTHONPYCACHEPREFIX="/tmp/.pytest_cache"
    MAJOR_VERSION = "0"
    MINOR_VERSION = "1"
    FLIT_USERNAME = "oterrier"
    FLIT_PASSWORD = "5C#P4N2yLL!P"
    GIT_AUTH = credentials('bitbucket-user')
  }

//   agent {
//       node {
//         label 'master'
//         customWorkspace "/home/jenkins/${env.JOB_NAME}"
//       }
//   }

  agent none

  stages {

    stage('Generate new version') {
      agent {
          node {
            label 'master'
            customWorkspace "/home/jenkins/${env.JOB_NAME}"
          }
      }

      stages {

        stage('Git commit/push new version file') {
          steps {
            script {
              println("attempt to publish with env.BUILD_ID = ${env.BUILD_ID}")
              sh "echo '\"\"\"Sherpa knowledge import plugins\"\"\"' > pyimporters_dummy/__init__.py"
              sh "echo '__version__ = \"${MAJOR_VERSION}.${MINOR_VERSION}.${env.BUILD_ID}\"' >> pyimporters_dummy/__init__.py"
//               sh('''
//                 git config --remove-section credential >/dev/null 2>&1 || true
//                 git config --remove-section user >/dev/null 2>&1 || true
//                 git config --global push.default matching
//                 git config user.name 'Guillaume Karcher'
//                 git config user.email 'guillaume.karcher@kairntech.com'
//                 git commit pyimporters_dummy/__init__.py -m "[Jenkins CI] Commit on version files" || echo "No changes to commit"
//                 git config --local credential.helper "!f() { echo username=\\$GIT_AUTH_USR; echo password=\\$GIT_AUTH_PSW; }; f"
//                 git push
//                 git config --remove-section credential
//                 git config --remove-section user
//               ''')
            }
          }
        }

      }
    }

    stage("build and test the project") {
      agent {
        dockerfile {
          label 'master'
          customWorkspace "/home/jenkins/${env.JOB_NAME}"
          filename 'Dockerfile'
          args "-u root --privileged -v /tmp/_${env.JOB_NAME}/test-reports:/root/test-reports"
        }
      }

      stages {

        stage('Build') {
          steps {
            sh 'pip install --no-cache-dir flit'
            sh 'flit install'
          }
        }

        stage('Test') {
          steps {
            sh "py.test --verbose -o cache_dir=/tmp/.pytest_cache --junit-xml /root/test-reports/results.xml"
            sh 'rm -rf /tmp/.pytest_cache'
          }
        }

        stage('Publish') {
          steps {
            sh 'flit publish'
            sh 'rm -rf dist'
          }
        }
      }

      post {
        // only triggered when blue or green sign
        //success {
        //}
        // triggered when red sign
        //failure {
        //}
        // trigger every-works
        always {
          println "reading report file [/tmp/_${env.JOB_NAME}/test-reports/results.xml]"
          //This junit step archives the JUnit XML report (generated by the py.test command above) and
          //exposes the results through the Jenkins interface.
          //The post section’s always condition that contains this junit step ensures that the step is
          //always executed at the completion of the Test stage, regardless of the stage’s outcome.
          sh "ln -s /tmp/_${env.JOB_NAME}/test-reports/results.xml $WORKSPACE"
          junit 'results.xml'
        }
      }
    }


  }

}


